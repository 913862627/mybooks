“分析，是在采取行动前对问题的研究”——DeMarco,1978

    软件开发，就是将问题空间映射到解空间的过程，分析（analysis）则是系统设计、实现的基础，它完成了首次映射过程。分析最主要的目标，概括说就是更好地理解问题空间，并用开发人员的语言对需求进行描述和归约。

    分析模型（analysis model）是分析的最终结果。分析模型，是层次化的分析包（analysis package），它包含分析类（analysis class）和用况实现-分析（use case realization-analysis）。分析模型从需求捕获（requirement capture）的结果（用况模型）作为输入，但对需求有着更为精确的规约。它用开发人员的语言对需求进行描述，更加形式化，也可以用作对系统内部工作方式的推断。和需求模型相比，分析模型更容易理解、整理、改变、维护。由于分析模型不仅简单列举了需求，同时它是可维护的，因此分析模型可以被看成是设计模型的原型，并作为系统设计、实践阶段的必要输入，这也是分析模型的重要之处。

    分析模型是从用况模型（use case model）中归约而来，和用况模型相比，他们有着显著的区别。首先，用况模型是从系统外部视图的角度、以用户的观点描述系统，它通过用况进行构造，提供了系统外部视图的结构；分析模型则是从系统内部视图的角度、以开发人员的观点来描述，它通过构造型类和包来构造，提供了系统内部视图的结构。其次，用况模型用于用户和开发人员的沟通，用来确定系统的功能；分析模型则是开发人员用于理解如何构造系统。用况模型中可能存在不一致和冲突的现象，在分析模型中，通过对用况模型的分析，应当消除这些冲突。用况模型定义了分析模型需要进一步分析的用况，而在分析模型中的每一个用况实现代表了一个对用况模型中的用况分析。

    分析模型虽然可以作为设计阶段的最初输入，但是，分析模型和设计模型（design model）有着很多的不同。首先，建立分析模型的目的还是在于理解问题，它是一种理想化的设计；而设计模型侧重于解决问题，它需要考虑系统性能等实际因素。其次，分析模型是从系统的行为进行思考，涉及系统的结构；设计模型则从根接近于编成的角度，设计属性和操作。最后，分析模型只考虑系统的功能性需求，然而设计模型则还要考虑系统的非功能性需求。

    建立分析模型的第一步就是根据用况模型识别分析类。所谓分析类，就是分析阶段的抽象的类，代表了设计和实现阶段的一个或者多个类。它侧重于处理功能需求，通过较高的、非形式化层次的职责来定义行为。分析类可以有属性，但是这些属性都是概念上的，是从问题域来考虑的。分析类所设计的关系，都是概念化的类。分析类既是分析的结果，也可以看作设计的初始，因此分析类虽然具有设计的特点，但同时又是高抽象程度和概念化的。在设计阶段，涉及人员根据分析模型建立设计模型，这个时候，分析类就会被细化为一个或者多个的设计类，它的属性以及它们之间的关系也会被细化为设计阶段的概念。

    分析类具有三种构造型：边界类（boundary class），实体类（entity class），控制类（control class）。边界类用于建立系统与其参与者之间的交互模型，它位于系统的外围，但属于系统。它和用户进行交互，也同时和系统内其他的分析类交互。边界类不应该指明实现的细节，它应该只给出交互的接口。实体类用于对持久信息建模，是对事实或概念的信息及相关的行为建模。实体类通常直接由领域（对象）模型中的领域类生成，但与领域类不同，实体类反映一种研究中的类，而领域类则是现实领域中存在的。实体类中通常展现了逻辑数据结构，这并非为了实现，而是为了帮助开发人员理解系统所依赖的信息。控制类代表了协调、排序、事务处理以及对其他对象的控制，经常用于封装于某个具体用况有关的控制，因此通常对于每个用况生成一个控制类。控制类还用于代表那些复杂的计算逻辑，但是它不会用来描述那些与用户之间的交互。

    分析类产生的分析类可能会有很多，同时由于需求的易变性，往往会导致分析类的变化，这就会造成分析模型难以维护的现象。这时就需要使用分析包将分析模型打包，将其分解到一个可控的范围内。分析包可以包含分析类、用况实现以及其他的分析包（因为它们都是分析模型的组成）。在对分析模型打包的过程中（也就是形成分析包的过程），应该把握“高内聚，低耦合”的原则，由于分析包是高内聚、低耦合的，这样虽然分析模型（分析类、用况实现）会发生变化，但是分析包的变化却是有限的，而所有的变化都发生在分析包的内部这样一个有限的范围内，这直接导致了模型可维护性的增强。

    分析包往往体现了分析中的一个关注点，应该依据系统的功能性需求和领域问题进行划分，它同时也应该被具有相关领域知识的人员理解，由此，分析包也是用户和开发人员之间交流的一种语言。分析包往往最终成为设计和实现阶段中的处于应用层高层的子系统，有时候它也直接反映了设计阶段整个的应用层。

    在识别了分析类、建立了分析包以后，就需要对每个用况模型进行具体分析，从而生成用况实现-分析。用况实现-分析是分析模型内部的一种协作，它利用分析类及它们之间的交互描述了特定用况的实现方法和行为，是用开发人员的语言重新归约用况模型中的特定用况。具体来说，用况实现-分析拥有一个对用况的文字性描述，同时利用类图展现了用况的静态结构（它所涉及到的分析类及其之间的关系），利用行为视图（顺序图、协作图、交互图等）说明用况的动态行为。同样，用况实现-分析只关注系统的功能性需求，而对于非功能性需求，则延迟到设计和实现阶段完成。

    在这之后，分析人员还要进行系统的框架分析。框架分析的目的有：选择适当的系统框架，以及框架模式、分析机制；说明重用策略；它也是计划过程的输入。框架分析最重要的活动就是发现重要的框架工件，一般而言，分析包及其依赖、关键分析类在框架分析中被认为是重要的。对于分析包而言，由于对分析包的分解，往往会影响设计和实现阶段的子系统，因此分析包对框架有重要的影响。而对于关键分析类，它们一般封装了领域模型中重要的事情（实体类）、交互接口和用户接口（边界类）、重要系统行为，而且这些分析类是对系统的概括，它处于分析活动的中心。

    分析活动，既是对用户需求的一次总结，有时对开发人员的指导，因此做好分析在软件开发中有着十分重要的意义。



对于分析的补充　　　kid 发表于 2005-12-7 23:07:00

我个人对于方法论是不太感冒的，虽然名义上我就是研究方法论的……也许是还没到那个级别吧。但是做学问就要严谨，尽管之前的那篇文章不是很严谨，已留下的问题就由这篇说明。

遗留下来最大的问题就是对于分析活动的步骤，我个人觉得应该首先识别分析类，然后形成分析包，在进行产生用况实现，最后进行构架分析。为什么首先识别分析类？因为识别过程是简单的，甚至是有些机械化的。根据用况图以及相关的领域知识就可以很快的发现分析类，这里不要费太多脑筋。分析类有了，分析包的形成就变得顺理成章了。将功能相近的——换句话说就是那些能够“高内聚、地耦合”的地类组成分析包，并归约出他们之间的关系。这就好像我们已经有了一堆彩色气球，那么按照颜色分类打包、排序就是那么的简单。有了分析类和分析包，我们就有能力产生用况实现。注意到用况实现只针对某个用况，因此没有必要在构架分析之后进行，或者说它并不依赖构架分析的结果；同时它所使用的元素应该是分析类（或者它的实例），因此它必须在识别分析类之后进行。当我们有了分析包，我们对系统构架就可以有了一个初步的划分，再加上用况实现，我们有足够的能力进行构架分析。构架分析是对之前分析的一个提高，如果没有之前的工作，那么构架分析可能是很困难的。

不同的观点认为，构架分析应该在第一步，RUP似乎就是这么说的。当然，这么说的人都是大牛，我也没有反驳他们的意思，我这只是个人感受罢了，其实没有什么说服力。不过，方法论这种东西本来就是仁者见仁的事情，而研究方法论的本质就是为了更好的进行软件开发，因此，从唯物主义的角度来说，只要符合软件开发的客观规律、能够以更快更高质量的完成软件开发的活动，那么什么使用方法论是不重要的。

至于其他的翻译问题，比如曾经和stack讨论过的，phenomenon到底翻译为“现象”还是“事实”，我个人觉得“现象”一词有太多动态的意味，比如一个试验的现象：镁条燃烧发出明亮的白光，它更多是代表一个过程。但是“事实”一词给人的感觉是静态的、客观的。实体类应该是反映一种静态的信息，因此“事实”似乎也能说得通。phenomenon一词在英语里的解释为：可以被感知的事实、突发事件或者环境。


Re:对于分析的补充　　　ai(游客)发表评论于2005-12-13 11:16:00

ai(游客)

觉得这个过程的顺序性没那么强,不可能完全在分析包产生后才产生架构（比如说如可能项目构想里就写明了系统是一个web应用,那进行任何分析之前,仅凭直觉系统就已经被分层了）,反之在分析之前完全产生架构也是不可能,RUP里的意思应该也是逐步精化

个人理解,架构分析这个东西,自顶向下和自底向上应该是并存,kaka

以下为blog主人的回复：

 我也希望是这样，不过答案总是固定的……
